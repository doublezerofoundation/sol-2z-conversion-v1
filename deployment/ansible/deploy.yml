---
- name: Deploy Swap Oracle Service
  hosts: all
  gather_facts: yes
  become: no
  serial: "{{ deployment_strategy | default('50%') }}"
  vars:
    app_name: swap-oracle-service
    app_version: "{{ version | default('latest') }}"
    aws_region: "{{ ansible_env.AWS_REGION | default('us-east-1') }}"
    account_id: "{{ ansible_env.AWS_ACCOUNT_ID }}"
    container_port: 8080
    health_check_endpoint: "api/v1/health"
    max_retries: 5
    retry_delay: 10
    deployment_timeout: 300

  pre_tasks:
    - name: Check if instance is ready
      wait_for:
        port: 22
        host: "{{ ansible_host }}"
        timeout: 60
      delegate_to: localhost
      when: ansible_connection != 'aws_ssm'

    - name: Gather AWS Account ID
      shell: aws sts get-caller-identity --query Account --output text
      register: aws_account_result
      delegate_to: localhost
      run_once: true
      when: account_id is not defined

    - name: Set AWS Account ID
      set_fact:
        account_id: "{{ aws_account_result.stdout }}"
      when: aws_account_result.stdout is defined

  tasks:
    - name: Check Docker service status
      systemd:
        name: docker
      register: docker_status

    - name: Ensure Docker is running
      become: yes
      systemd:
        name: docker
        state: started
        enabled: yes
      when: docker_status.status.ActiveState != 'active'

    - name: Check if user is in docker group
      shell: groups {{ ansible_user }} | grep -q docker
      register: docker_group_check
      ignore_errors: yes

    - name: Add user to docker group if needed
      become: yes
      user:
        name: "{{ ansible_user }}"
        groups: docker
        append: yes
      when: docker_group_check.rc != 0

    - name: Reset SSH connection to pick up group changes
      meta: reset_connection
      when: docker_group_check.rc != 0

    - name: Login to ECR
      shell: |
        aws ecr get-login-password --region {{ aws_region }} | \
        docker login --username AWS --password-stdin {{ account_id }}.dkr.ecr.{{ aws_region }}.amazonaws.com
      register: ecr_login
      retries: 3
      delay: 5

    - name: Pull latest image
      docker_image:
        name: "{{ account_id }}.dkr.ecr.{{ aws_region }}.amazonaws.com/{{ app_name }}"
        tag: "{{ app_version }}"
        source: pull
        force_source: yes
      register: image_pull
      retries: 3
      delay: 10

    - name: Stop existing container
      docker_container:
        name: "{{ app_name }}"
        state: absent
        force_kill: yes
      ignore_errors: yes

    - name: Remove old container
      docker_container:
        name: "{{ app_name }}-old"
        state: absent
      ignore_errors: yes

    - name: Create application directories
      file:
        path: "{{ item }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      loop:
        - /opt/app/logs
        - /opt/app/config
      become: yes

    - name: Run new container
      docker_container:
        name: "{{ app_name }}"
        image: "{{ account_id }}.dkr.ecr.{{ aws_region }}.amazonaws.com/{{ app_name }}:{{ app_version }}"
        state: started
        restart_policy: unless-stopped
        ports:
          - "{{ container_port }}:{{ container_port }}"
        volumes:
          - "/opt/app/logs:/app/logs"
          - "/opt/app/config:/app/config"
        env:
          NODE_ENV: "{{ environment | default('production') }}"
          AWS_REGION: "{{ aws_region }}"
          LOG_LEVEL: "{{ log_level | default('info') }}"
        healthcheck:
          test: ["CMD", "curl", "-f", "http://localhost:{{ container_port }}{{ health_check_endpoint }}"]
          interval: 30s
          timeout: 10s
          retries: 3
          start_period: 60s
        log_driver: json-file
        log_options:
          max-size: "10m"
          max-file: "3"
      register: container_start

    - name: Wait for container to be healthy
      wait_for:
        port: "{{ container_port }}"
        host: localhost
        delay: 10
        timeout: "{{ deployment_timeout }}"
      when: container_start.changed

    - name: Health check - wait for service to respond
      uri:
        url: "http://localhost:{{ container_port }}{{ health_check_endpoint }}"
        method: GET
        status_code: 200
      register: health_check
      retries: "{{ max_retries }}"
      delay: "{{ retry_delay }}"
      until: health_check.status == 200

    - name: Verify container is running
      docker_container_info:
        name: "{{ app_name }}"
      register: container_info

    - name: Fail if container is not running
      fail:
        msg: "Container {{ app_name }} is not running"
      when: container_info.container.State.Status != "running"

  post_tasks:
    - name: Clean up old images
      shell: |
        docker image prune -f
        docker system prune -f --volumes
      ignore_errors: yes

    - name: Log deployment success
      debug:
        msg: |
          âœ… Deployment successful!
          Service: {{ app_name }}
          Version: {{ app_version }}
          Environment: {{ environment | default('production') }}
          Container ID: {{ container_info.container.Id[:12] }}
          Health Status: {{ health_check.status }}

  handlers:
    - name: restart docker
      become: yes
      systemd:
        name: docker
        state: restarted